**En este archivo se explica como se realizó la interacción con el periférico de la pantalla LCD 16X02**
- [lcd1602\_controller.v](#lcd1602_controllerv)
  - [Descripción de Hardware](#descripción-de-hardware)
  - [Maquina de estados](#maquina-de-estados)
- [lcd1602\_cust\_char.v](#lcd1602_cust_charv)
- [task\_manager.v](#task_managerv)


# lcd1602_controller.v

El modulo lcd1602_controller.v es diseñado para interactuar con el periferico de la pantalla LCD 16X02. Su objetivo es mostrar en el display: (1) la cara del tamagochi (que representa su estado actual) y (2) los valores de cada una de las tres estadisticas: food, joy y energy, tal como se muestra en la figura a continuación.

![diagrama-lcd](https://github.com/user-attachments/assets/1bfb950e-6642-411a-a4ca-cff4f2e7c91c)

El display LCD 1602 utilizado tiene 32 bloques distribuidos en 2 filas y 16 columnas. Cada bloque tiene asignada una dirección DDRAM (Display Data RAM), tal como se muestra a continuación:
![DDRAM_address](https://github.com/user-attachments/assets/78eeedab-d51c-493c-a513-f6f34dae7ac3)

Cada uno de los 32 bloques es una matriz de puntos de 8 filas y 5 columnas. 

## Descripción de Hardware
![cajaNegra](https://github.com/user-attachments/assets/3746b32a-9f06-4962-90ef-afae16a8b3a6)

- **RS (Register Select):** Determina si se va a enviar un comando o un dato a la pantalla.
    - RS = 0: Se envía un comando (instrucción) para configurar la pantalla (ej: limpiar pantalla, mover cursor, etc.).
    - RS = 1: Se envía un dato (carácter) para que sea mostrado en la pantalla.
- **RW (Read/Write):** Indica si se va a leer o escribir en la pantalla. 
  - RW = 0 inidica Escritura (la más común). Se envía  información desde el microcontrolador a la pantalla.
  - RW = 1 indica Lectura. Se lee información desde la pantalla al microcontrolador (no tan utilizado).

- **Enable (E)**: Funciona como un pulso de reloj, en este caso, con periodo de 16ms. Al generar un flanco de subida en este pin, la pantalla toma los datos presentes en los pines de datos.

- **Data[7:0]**: corresponde a un bus de 8 bits. A través de este se envían los comandos o datos (caracteres) a la pantalla.


## Maquina de estados


0. **IDLE (Inactivo):**
   * Restablece diversas señales de control y contadores.
   * Prepara el módulo para el siguiente estado.

``` verilog
IDLE: begin
    init_config_executed <= 0; // restet flag
    initial_paint_text_done <= 0; // restet flag
    initial_paint_values_done <= 0; // restet flag
    initial_paint_cara_done <= 0; // restet flag
    carita_executed <= 0; // restet flag
    values_executed <= 0; // restet flag
    set_task <= 0; // restet counter
    counter_data <= 'b0; // restet counter
    num_cust_char_cara <= 0; // reset register, IDLE FACE == 0
    data_reg <= 'b0; // restet register
    rs_reg <= 'b0; // restet register
end
```

1. **INIT_CONFIG (Configuración Inicial):**
Inicializa la pantalla LCD con comandos específicos.
     * **CLEAR_DISPLAY (`0x01`):** Limpia la pantalla y devuelve el cursor a la posición inicial (dirección 0).
     * **DISPON_CURSOROFF (`0x0C`):** Pantalla encendida, cursor apagado, parpadeo apagado.
     * **LINES2_MATRIX5x8_MODE8bit (`0x38`):** Interfaz de 8 bits, 2 líneas, matriz de puntos de 5x8.

```verilog
INIT_CONFIG: begin
    case(counter_data)
        0: begin rs_reg <= 0; data_reg <= LINES2_MATRIX5x8_MODE8bit; counter_data <= 1; end
        1: begin rs_reg <= 0; data_reg <= DISPON_CURSOROFF; counter_data <= 2; end
        2: begin rs_reg <= 0; data_reg <= CLEAR_DISPLAY; counter_data <= 3; end
        3: begin counter_data <= 0; init_config_executed <= 1; end
        default: counter_data <= 0;
    endcase
end
```

2. **INITIAL_PAINT_CARA (Pintar Caras Inicialmente):**
   * Utiliza un registro `set_task` para gestionar el proceso de pintado.
   * Verifica si la pantalla LCD está disponible para pintar y establece las señales adecuadas con el fin de utilizar el modulo [lcd1602\_cust\_char.v](#lcd1602_cust_charv) para pintar la cara.

```verilog
INITIAL_PAINT_CARA:begin
  case(set_task)
    SET_CARITA: begin
      num_cust_char_cara <= 0; // IDLE FACE == 0
      set_task <= START_PAINT;
    end
    START_PAINT: begin
      set_task <= (lcd_available_cara)? START_PAINT : PAINTING;
      start_painting_cara <= (lcd_available_cara)? 1 : 0; // señal de start que se envía al módulo lcd1602_cust_char
    end
    PAINTING: begin
      if (lcd_available_cara) begin // verifica si la pantalla está disponible
          initial_paint_cara_done <= 1; // flag para indicar que se pintó la cara
          set_task <= 0; // resetear la tarea para que pueda ser reutilizada
      end
    end
  endcase
end
```

1. **INITIAL_PAINT_VALUES (Pintar Valores Iniciales):**
   * Pinta valores iniciales en la pantalla LCD.
   * Utiliza un contador `counter_data` para secuenciar el proceso de pintado de valores.
   * Escribe números predefinidos `string_numbers` en direcciones específicas de la pantalla LCD.
  
```verilog
INITIAL_PAINT_VALUES: begin
    case(counter_data)
        // Se mueve el cursor a la posición de la LCD donde se pintará el valor de FOOD
        0: begin rs_reg <= 0; data_reg <= initial_lcd_address[FOOD_VALUE]; counter_data <= 1; end
        // Se pinta el numero 5 en la LCD
        1: begin rs_reg <= 1; data_reg <= string_numbers[5]; counter_data <= 2; end
        // Se mueve el cursor a la posición de la LCD donde se pintará el valor de JOY
        2: begin rs_reg <= 0; data_reg <= initial_lcd_address[JOY_VALUE]; counter_data <= 3; end
        // Se pinta el numero 5 en la LCD
        3: begin rs_reg <= 1; data_reg <= string_numbers[5]; counter_data <= 4; end
        // Se mueve el cursor a la posición de la LCD donde se pintará el valor de ENERGY
        4: begin rs_reg <= 0; data_reg <= initial_lcd_address[ENERGY_VALUE]; counter_data <= 5; end
        // Se pinta el numero 5 en la LCD
        5: begin  rs_reg <= 1; data_reg <= string_numbers[5]; counter_data <= 0; initial_paint_values_done <= 1; end
        default: counter_data <= 0;
    endcase
end
```

4. **INITIAL_PAINT_TEXT (Pintar Texto Inicial):**
En este estado se pinta las cadenas de texto predefinidas `FOOD`, `JOY`, `ENERGY` en direcciones DDRAM específicas de la pantalla LCD .

```verilog
INITIAL_PAINT_TEXT:begin   
    case(counter_data)
        0: begin rs_reg <= 0; data_reg <= 0; counter_data <= 1; end
        // Se pinta el texto FOOD en la LCD usando caracteres ascii
        1: begin rs_reg <= 0; data_reg <= initial_lcd_address[FEED_TEXT]; counter_data <= 2; end
        2: begin rs_reg <= 1; data_reg <= string_food[0]; counter_data <= 3; end
        3: begin rs_reg <= 1; data_reg <= string_food[1]; counter_data <= 4; end
        4: begin rs_reg <= 1; data_reg <= string_food[2]; counter_data <= 5; end
        5: begin rs_reg <= 1; data_reg <= string_food[3]; counter_data <= 6; end
        // Se pinta el texto JOY en la LCD usando caracteres ascii
        6: begin rs_reg <= 0; data_reg <= initial_lcd_address[JOY_TEXT]; counter_data <= 7; end
        7: begin rs_reg <= 1; data_reg <= string_joy[0]; counter_data <= 8; end
        8: begin rs_reg <= 1; data_reg <= string_joy[1]; counter_data <= 9; end
        9: begin rs_reg <= 1; data_reg <= string_joy[2]; counter_data <= 10; end
        // Se pinta el texto ENERGY en la LCD usando caracteres ascii
        10: begin rs_reg <= 0; data_reg <= initial_lcd_address[ENERGY_TEXT]; counter_data <= 11; end
        11: begin rs_reg <= 1; data_reg <= string_energy[0]; counter_data <= 12; end
        12: begin rs_reg <= 1; data_reg <= string_energy[1]; counter_data <= 13; end
        13: begin rs_reg <= 1; data_reg <= string_energy[2]; counter_data <= 14; end
        14: begin rs_reg <= 1; data_reg <= string_energy[3]; counter_data <= 15; end
        15: begin rs_reg <= 1; data_reg <= string_energy[4]; counter_data <= 16; end
        16: begin rs_reg <= 1; data_reg <= string_energy[5]; counter_data <= 17; end
        // Se resetea counter_data y se activa la bandera de que indica que ya se pintó todo el texto
        17: begin rs_reg <= 0; data_reg <= 0; counter_data <= 0; initial_paint_text_done <= 1; end
        default: counter_data <= 0;
    endcase
end
```

5. **CHECK_UPDATES (Verificar Actualizaciones):**
   * Estado en el que se espera la aparición de alguna actualización. Por lo que, se restablece las banderas `carita_executed` y ``values_executed``.

   * Una vez la señal ``new_change`` controlada por la instancia del módulo [task\_manager.v](#task_managerv) toma el valor de 1, se procede al siguiente estado, es decir, a pintar la actualización.


```verilog
CHECK_UPDATES: begin
    carita_executed <= 0; // reset flag
    values_executed <= 0; // reset flag
    data_reg <= 0;
    rs_reg <= 0;
end
```

6. **PAINT_CARA (Pintar Cara):**
   * Similar a `INITIAL_PAINT_CARA` pero para actualizar la cara.
   * Utiliza una tarea `set_task` para gestionar el proceso de pintado.


```verilog
PAINT_CARA:begin
    case(set_task)
        SET_CARITA: begin
            num_cust_char_cara <= face;
            set_task <= START_PAINT;
        end
        START_PAINT: begin
            set_task <= (lcd_available_cara)? START_PAINT : PAINTING;
            start_painting_cara <= (lcd_available_cara)? 1 : 0;
        end
        PAINTING: begin
            if (lcd_available_cara) begin
                carita_executed <= 1;
                set_task <= 0;
            end
        end
    endcase
end

```

7. **PAINT_VALUES (Pintar Valores):**
  * Similar a `INITIAL_PAINT_VALUES` pero para actualizar los valores mostrados en la pantalla LCD.

```verilog
PAINT_VALUES: begin
    case(counter_data)
        0: begin rs_reg <= 0; data_reg <= initial_lcd_address[FOOD_VALUE]; counter_data <= 1; end
        1: begin rs_reg <= 1; data_reg <= string_numbers[food_value]; counter_data <= 2; end
        2: begin rs_reg <= 0; data_reg <= initial_lcd_address[JOY_VALUE]; counter_data <= 3; end
        3: begin rs_reg <= 1; data_reg <= string_numbers[joy_value]; counter_data <= 4;  end
        4: begin rs_reg <= 0; data_reg <= initial_lcd_address[ENERGY_VALUE]; counter_data <= 5; end
        5: begin  rs_reg <= 1; data_reg <= string_numbers[energy_value]; counter_data <= 0; values_executed <= 1;  end
        default: counter_data <= 0;
    endcase
end
```


# lcd1602_cust_char.v

Para dibujar un patrón personalizado de 5×8, primero debemos guardarlo en la CGRAM. Para ello, necesitamos escribir los valores que definen el estado deseado de cada pixel (si brilla o no) en el área CGRAM.

Estos valores se deben escribir en las direcciones a partir de la 0x40 hasta la 0x78. La CGRAM tiene un total de 64 bytes. Cuando se utiliza la pantalla LCD como bloques de 5x8 pixeles, se emplea 1 byte para cada fila y 8 filas para cada patrón. De modo que, sólo se pueden definir hasta un total de 8 patrones customizados en la CGRAM. 

Para representar cada estado del tamagochi, se mostrará una cara en la LCD. Cada cara está compuesta de 6 bloques 5x8, es decir, una cara ocupa 6 direcciones de CGRAM, para un total 48 bytes.

 - Sets the address of the CGRAM (Character Generator RAM).
|       | D7  | D6  | D5  | D4  | D3  | D2  | D1  | D0  | Dirección inicial | Dirección Final |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- | ----------------- | --------------- |
| DDRAM | 1   | x   | x   | x   | x   | x   | x   | x   | 0x80              | 0xFF            |
| CGRAM | 0   | 1   | x   | x   | x   | x   | x   | x   | 0x40              | 0x7F            |


![alt text](./entrega-1-proyecto-grupo01-2024-1/figs/pinout.png)

# task_manager.v
La instancia del módulo [task\_manager.v](#task_managerv) es la encargada de monitorear los valores de face, food_value, joy_value y energy_value con el fin de inidicar con la señal `new_change` cuando a ocurrido un cambio de dichos de valores.
